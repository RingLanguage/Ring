golang 1.0 是抢占式还是协作式




非常好的问题！这是一个理解 Go 调度器演进的关键点。

**Go 1.0 的调度器是纯粹的协作式（Cooperative），而非抢占式（Preemptive）。**

下面我详细解释一下这两种方式的区别，以及为什么 Go 1.0 采用协作式，并如何体现代码中。

### 协作式 vs 抢占式

| 特性           | 协作式 (Cooperative)           | 抢占式 (Preemptive)                      |
| :------------- | :----------------------------- | :--------------------------------------- |
| **控制权转移** | Goroutine **主动**让出 CPU     | 调度器**强制**剥夺 Goroutine 的 CPU 时间 |
| **实现方式**   | 在函数调用时插入检查点         | 通过操作系统中断（如时钟信号）           |
| **优点**       | 实现简单，上下文切换开销小     | 公平性更好，能防止单个协程饿死整个程序   |
| **缺点**       | 一个协程不配合就会阻塞整个线程 | 实现复杂，上下文切换开销较大             |
| **Go 1.0**     | **✅ 采用**                     | **❌ 未采用**                             |

### 为什么 Go 1.0 采用协作式？

1.  **实现简单**：Go 语言设计初衷之一就是"简单"。协作式调度器更容易实现和推理，非常适合早期版本验证核心概念。
2.  **性能考虑**：协作式切换发生在明确的代码点（如函数调用），只需保存必要的寄存器，上下文切换开销极小。
3.  **受传统影响**：早期的并发模型（如协程）大多采用协作式。

### Go 1.0 中的协作式调度体现

在 Go 1.0 中，Goroutine 在以下**特定时机**会主动让出 CPU，触发调度：

#### 1. 主动调用 `runtime.Gosched()`

这是最直接的协作方式。开发者明确告诉调度器："我现在可以暂停，让其他 Goroutine 运行"。

```go
package main

import (
    "runtime"
    "fmt"
)

func main() {
    go func() {
        for i := 0; i < 5; i++ {
            fmt.Println("Goroutine 1")
        }
    }()

    go func() {
        for i := 0; i < 5; i++ {
            fmt.Println("Goroutine 2")
            runtime.Gosched() // 主动让出CPU
        }
    }()

    runtime.Gosched() // 让上面的goroutine有机会执行
    fmt.Println("Main done")
}
```

#### 2. 进行网络、通道、定时器等 I/O 操作

当 Goroutine 执行可能会阻塞的操作时，调度器会介入。

```go
// 当执行这些操作时，Go 1.0 的调度器会挂起当前G，运行其他G
ch <- data       // 通道发送
<-ch            // 通道接收
time.Sleep(...) // 睡眠
net.Dial(...)   // 网络操作
```

#### 3. 函数调用（隐含的调度点）

这是协作式调度的关键机制。**在函数调用的序言（prologue）中，Go 1.0 的运行时可能会检查是否需要调度**。

在 `src/pkg/runtime/asm_amd64.s` 中，你会看到类似这样的汇编代码：

```assembly
// 函数调用的前奏，可能会检查stackguard，也可能会检查调度
TEXT runtime·morestack(SB),...
    // ... 检查是否需要扩展栈 ...
    // 这里也可能是一个潜在的调度点
```

### 协作式调度的问题与 Go 1.0 的"弱抢占"尝试

纯粹协作式调度的最大问题是：**如果一个 Goroutine 执行一个长时间的计算循环，中间没有任何函数调用，它就会一直占用线程，导致其他 Goroutine 饿死。**

```go
// 这个循环会阻塞整个线程（在Go 1.0中）
go func() {
    for {
        // 密集计算，没有函数调用
        i += 1
    }
}()
```

为了解决这个问题，Go 1.0 和 1.1 引入了一种非常初级的"抢占"机制，但它是**协作式的抢占**，而非真正的强制抢占：

**基于栈增长检查的抢占（Stack Preemption）**

1.  **监控器**：Go 运行时有一个后台监控线程 `sysmon`。
2.  **标记请求**：`sysmon` 会定期检查运行时间过长的 G，并设置一个标记（如 `g->preempt = true`）。
3.  **协作点检查**：**只有在函数调用时**，运行时才会检查这个抢占标记。如果标记被设置，就暂停当前 G，进行调度。

```c
// 在 proc.c 的调度器代码中，可能会有这样的检查逻辑
if(g->preempt) {
    g->preempt = false;
    // 触发重新调度
    runtime·gosched();
}
```

**关键限制**：如果 Goroutine 一直在执行一个**没有函数调用**的紧密循环，这个抢占标记就永远没有机会被检查，Goroutine 也就不会被抢占。

### 演进历程

| 版本              | 调度模式                            | 特点                                             |
| :---------------- | :---------------------------------- | :----------------------------------------------- |
| **Go 1.0 ~ 1.1**  | **协作式** + 基于栈增长的弱抢占     | 在函数调用时检查抢占标记                         |
| **Go 1.2 ~ 1.13** | **协作式** + 改进的基于栈增长的抢占 | 在函数序言中更频繁地插入抢占检查                 |
| **Go 1.14+**      | **真正的基于信号的抢占**            | 通过异步信号强制抢占，即使在没有函数调用的循环中 |

### 总结

- **Go 1.0 是协作式调度器**，依赖 Goroutine 在函数调用、I/O 操作或主动调用 `Gosched()` 时让出 CPU。
- 它通过**基于栈增长的检查**实现了一种"协作式抢占"，但这只在函数调用时有效。
- 这种设计的**简单性**是 Go 1.0 的核心价值，但也暴露了协作式调度的根本缺陷，直接推动了后续版本向真正抢占式调度的发展。

研究 Go 1.0 的协作式模型，能让你深刻理解为什么现代 Go 需要引入如此复杂的基于信号的抢占机制。