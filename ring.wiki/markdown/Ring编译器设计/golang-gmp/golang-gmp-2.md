golang 的并发模型中，当G因系统调用(syscall)阻塞时会阻塞M，此时P会和M解绑即hand off，并寻找新的idle的M，若没有idle的M就会新建一个M；这里的技术是如何实现的



好的，这是一个非常核心且精彩的Go调度器问题。它触及了Go能够高效处理高并发I/O的关键。下面我将详细拆解这个过程中的技术实现。

### 核心概念回顾

首先，我们快速回顾一下GMP模型中的三个角色：
*   **G (Goroutine)**: 代表一个Go协程，包含了要执行的函数、栈、上下文等信息。
*   **M (Machine)**: 代表一个操作系统线程（OS Thread）。真正被操作系统调度，在CPU上执行代码的实体。
*   **P (Processor)**: 代表一个“逻辑处理器”，它包含了运行Go代码所需的资源，比如一个本地Goroutine队列（local runqueue）。

### 问题场景：当G进行系统调用时

当一个G（例如执行`http.Get`的G）发起一个系统调用（如网络请求、文件读写）时，这个调用会导致当前执行它的**M（线程）被操作系统阻塞**。因为操作系统不知道Go的调度器，它只会让当前线程进入睡眠状态，直到系统调用完成（例如数据到达网络套接字）。

如果什么都不做，那么承载这个P的M就被卡住了，P上的其他G（可能在本地队列里还有几十个G）也就都无法执行了，严重浪费资源。

### 解决方案：Hand Off（解绑与抢占）的技术实现

Go调度器的解决方案正是你提到的 **“M与P解绑（hand off），P去寻找或创建一个新的M”**。这个过程主要由 `runtime` 包中的代码在底层实现，具体步骤如下：

#### 1. 进入系统调用前的准备 (`entersyscall`)

当G即将执行系统调用时（这是由编译器在生成代码时插入的），Go运行时（runtime）会介入。具体函数是 `runtime.entersyscall`。

*   **保存状态**：当前M会立刻保存G的执行上下文（寄存器状态等），以便未来系统调用返回后能恢复执行。
*   **原子标记P状态**：将当前P的状态从 `_Prunning` 设置为 `_Psyscall`。这是一个非常重要的原子操作。调度器通过这个状态知道“这个P所关联的M可能被阻塞了，需要帮忙”。
*   **解绑但不完全分离**：此时，P和M会**逻辑上解绑**，但P的 `M` 字段仍然指向这个阻塞的M（这是一种优化，称为`sysmon`轮询检查）。P被放入一个全局的`syscall`状态P列表中。

#### 2. 调度器的干预：`sysmon` 监控线程

Go运行时有一个特殊的后台监控线程，叫做 `sysmon` (system monitor)，它不绑定任何P，定期对整个程序进行扫描和治理。

*   **轮询检查**：`sysmon` 会每隔一段时间（比如20us~10ms，动态调整）检查所有处于 `_Psyscall` 状态的P。
*   **超时判断**：如果一个P处于 `_Psyscall` 状态已经超过了一个阈值（默认是20ms），`sysmon` 就会判定这个系统调用“耗时太长”，需要采取行动。
*   **抢夺P（Retake）**：`sysmon` 会执行 `retake` 逻辑，强制将这个P从它之前关联的、可能已经阻塞的M手中“抢过来”。

#### 3. Hand Off 的核心：为P分配新的M (`acquirep` 和 `wirep`)

当`sysmon`决定要抢夺一个P时，或者在某些系统调用开始时（如果能预知会长时间阻塞），就会触发hand off流程：

1.  **解除旧关联**：将P的状态从 `_Psyscall` 改为 `_Pidle`，并彻底清空P的 `M` 字段，使其与旧的M完全分离。
2.  **寻找空闲M**：调度器尝试为这个“空闲”的P寻找一个空闲的M（`idle M`）。
    *   **来源**：空闲M存放在一个全局的调度器结构（`sched`）的`midle`链表中，这是一个由空闲M组成的链表。
    *   **如果找到**：从链表中取出一个空闲M，通过 `wirep` 函数将P和这个新的M绑定。然后唤醒这个M（本质上是通过一个futex信号或semaphore信号），让它开始从P的本地运行队列中获取并执行G。
3.  **创建新M（如果没有空闲M）**：如果 `midle` 链表中没有可用的空闲M，运行时就会通过 `newm` 函数**创建一个新的操作系统线程（M）**。
    *   **如何创建**：在Unix-like系统上，最终会调用 `pthread_create` 系统调用创建一个新的线程。
    *   **新线程的入口点**：新创建的M的起始函数是 `mstart`，它会立即尝试与一个空闲的P绑定，然后开始执行G。
    *   这就是为什么在高并发的I/O型应用中，你会看到线程数（M的数量）短暂上升的原因，这是调度器在努力保持CPU资源被充分利用。

#### 4. 系统调用返回后的处理 (`exitsyscall`)

当阻塞的系统调用完成后，被阻塞的G（和它所在的M）终于被操作系统唤醒，继续执行。它的下一步是调用 `runtime.exitsyscall`。

此时，这个G需要找到一个P来继续运行。它尝试以下几种方式，**优先级从高到低**：

1.  **尝试绑定原来的P**：它会优先尝试获取它进入系统调用之前使用的那个P。如果那个P当前是空闲状态（`_Pidle`），并且没有被其他M占用，那么它就能成功重新绑定，非常高效。
2.  **尝试获取任何空闲的P**：如果原来的P已经被分配出去了（比如给了那个新创建的M），它会尝试从全局的空闲P列表中获取任何一个可用的P。
3.  **全局队列**：如果所有P都忙，那么这个G不能立即执行。它会被标记为可运行（`_Grunnable`），然后放入**全局运行队列（global runqueue）** 等待被某个有空闲的P的M捞起执行。
4.  **M的休眠**：这个刚刚被唤醒的M，如果**没有成功为它的G获取到任何一个P**，那么它自身的工作就完成了。它不会空转，而是会进入休眠状态，被加入到空闲M链表（`midle`）中，等待下次被调度器唤醒。

### 总结与技术要点

| 阶段           | 关键函数/组件          | 操作                                                   | 技术要点                         |
| :------------- | :--------------------- | :----------------------------------------------------- | :------------------------------- |
| **进入调用**   | `entersyscall`         | 保存G上下文，标记P为`_Psyscall`                        | 原子操作改变状态，非立即解绑     |
| **监控发现**   | `sysmon` -> `retake`   | 定期扫描，发现超时（>20ms）的P                         | 后台线程异步工作，是解绑的触发器 |
| **解绑与抢夺** | `retake` -> `releasep` | 将P状态改为`_Pidle`，与旧M分离                         | 强制剥夺，保证P的可用性          |
| **分配新M**    | `acquirep`, `wirep`    | 1. 从`midle`链找空闲M<br>2. 若无，则`newm`创建新OS线程 | 线程缓存（Pooling）与动态创建    |
| **调用返回**   | `exitsyscall`          | G尝试获取P（原P > 任意空闲P），失败则入全局队列        | 乐观锁（CAS）竞争P，失败降级     |

这种机制的巧妙之处在于：

1.  **异步监控**：通过`sysmon`线程避免了在每次系统调用时都要做昂贵判断的开销，只在必要时（超时）才进行Hand off。
2.  **状态驱动**：整个流程由P的状态（`_Prunning`, `_Psyscall`, `_Pidle`）驱动，通过原子操作保证一致性。
3.  **资源池化**：维护了一个空闲M的链表，避免了频繁创建和销毁OS线程的开销。
4.  **优化路径**：系统调用返回后尝试获取原P，这是一个高效的快速路径（fast path），对于短时的系统调用非常友好。

正是这套复杂而精密的机制，使得Go可以用少量的OS线程来支撑成千上万个Goroutine的并发，尤其在I/O密集型的场景下表现极其出色。