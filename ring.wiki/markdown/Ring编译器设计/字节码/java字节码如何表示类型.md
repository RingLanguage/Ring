很好！这是一个关于 Java 虚拟机底层细节的深入问题。你的直觉是正确的，JVM 在设计时充分考虑了空间效率，其类型系统正是基于“共享”和“符号引用”的理念来构建的。

下面我将详细解答你的两个问题。

### 1. 类型如何在字节码中保存的？

字节码中**并不直接存储**我们编程时看到的 `int`, `double`, `String`, `MyClass` 这些类型名称字符串。相反，它使用了一套高度精炼的编码系统。

#### 1.1 基本数据类型：使用单字符描述符

对于8种基本数据类型，JVM 规范预定义了固定的单字符编码：

| 类型      | 字节码描述符 | 说明         |
| :-------- | :----------- | :----------- |
| `byte`    | `B`          |              |
| `short`   | `S`          |              |
| `int`     | `I`          |              |
| `long`    | `J`          | *注意不是 L* |
| `float`   | `F`          |              |
| `double`  | `D`          |              |
| `char`    | `C`          |              |
| `boolean` | `Z`          |              |
| `void`    | `V`          | 用于返回值   |

**举例：**
- 一个接受 `int` 和 `double` 并返回 `boolean` 的方法，其描述符为：`(ID)Z`

#### 1.2 引用类型：使用“描述符” + 常量池索引

对于引用类型（类、数组、接口），字节码中存储的是一个**指向常量池的符号引用**。

- **类类型**：使用字母 `L` 开头，后跟**类的全限定名**（用 `/` 代替 `.`），最后以 `;` 结尾。
    - 例如：`Ljava/lang/String;` 表示 `java.lang.String` 类型。
    - 例如：`Lcom/example/MyClass;` 表示 `com.example.MyClass` 类型。

- **数组类型**：使用 `[` 开头，后跟数组元素的类型描述符。
    - 例如：`[I` 表示 `int[]`。
    - 例如：`[Ljava/lang/String;` 表示 `String[]`。
    - 例如：`[[D` 表示 `double[][]`。

**关键点：** 这些描述符字符串（如 `"Ljava/lang/String;"`）本身并不会在代码中重复出现。它们作为 **“CONSTANT_Utf8_info”** 表项存储在**常量池** 中。当字节码需要引用一个类型时，它只需要存储一个指向该常量池项的双字节索引。

#### 1.3 在字节码结构中的具体应用

- **方法描述符**：由参数类型描述符和返回值类型描述符组成，格式为 `(参数描述符)返回类型描述符`。
    - `public static void main(String[] args)` 的描述符是：`([Ljava/lang/String;)V`
    - `public boolean equals(Object obj)` 的描述符是：`(Ljava/lang/Object;)Z`

- **字段描述符**：直接使用该类型的描述符。
    - `String name` 字段的描述符是：`Ljava/lang/String;`
    - `int count` 字段的描述符是：`I`

- **局部变量类型**：在 `Code` 属性的 `LocalVariableTable` 中，每个局部变量条目都包含一个指向常量池的索引，该索引指向一个 `CONSTANT_Utf8_info`，其中存储了该变量的描述符（如 `I`, `J`, `Ljava/lang/String;`）。

---

### 2. 如何减少空间（共享与常量池）

你的理解完全正确，JVM 通过**运行时常量池** 完美地解决了类型共享的问题，避免了重复创建。

#### 2.1 常量池：字节码文件的“符号表”

每个 `.class` 文件都有一个常量池。你可以把它想象成一个由索引号管理的共享字典或库。

- **存储内容**：常量池中存放了类文件中出现的各种**符号信息**，包括：
    - 类和接口的全限定名（`CONSTANT_Class_info`）
    - 字段和方法的名称和描述符（`CONSTANT_Utf8_info`）
    - 字符串字面量（`CONSTANT_String_info`）
    - 数字常量（`CONSTANT_Integer_info` 等）

- **如何工作**：
    1. 当一个类型（例如 `java.lang.String`）第一次在类中被引用时，编译器会做两件事：
        a. 在常量池中创建一个 `CONSTANT_Utf8_info` 项，存储字符串 `"java/lang/String"`。
        b. 创建一个 `CONSTANT_Class_info` 项，该项内部包含一个指向步骤a中 `CONSTANT_Utf8_info` 的索引。
    2. 之后，在整个类文件的任何地方（方法代码、字段定义、父类声明等）需要用到 `java.lang.String` 这个类型时，都只需要存储指向那个 `CONSTANT_Class_info` 项的**索引值**（一个简单的数字，通常是2字节）。

#### 2.2 空间节省示例

假设一个类中有三个方法都使用了 `String` 类型：
- `public String getName()`
- `public void setName(String name)`
- `public void printString(String str)`

如果没有常量池：
- 每个方法都需要在自己的代码段里完整存储 `"Ljava/lang/String;"` 这个字符串，导致重复。

**有了常量池之后：**
1. 常量池中只有一个位置（比如索引 #5）存储了 `"Ljava/lang/String;"` 这个字符串。
2. 三个方法的描述符在字节码中分别被编译为：
    - `getName`: 指向 `(…)Ljava/lang/String;`，其中的 `Ljava/lang/String;` 部分实际上是一个指向 #5 的索引。
    - `setName`: 指向 `(Ljava/lang/String;)V`，其中的参数类型同样指向 #5。
    - `printString`: 同理。
3. 在 `LocalVariableTable` 中，`name` 和 `str` 这两个局部变量的类型描述符，也都是指向常量池 #5 的索引。

#### 2.3 方法区的进一步共享

当类被 JVM 加载时，`.class` 文件中的常量池会被转换到**方法区**的运行时常量池中。此时，JVM 还会进行进一步的优化和共享。

- **字符串驻留**：对于像 `"java/lang/String"` 这样的字符串，JVM 可能会将其内部化，确保在内存中只有一份。
- **类的元数据**：`Class` 对象等元数据也是在方法区中共享的。所有指向 `java.lang.String` 类的引用，在内存中最终都指向同一个 `Class` 对象。

### 总结

1.  **类型保存方式**：字节码不存类型名，而是用一套精简的**描述符系统**（如 `I` 代表 `int`, `L...;` 代表类）。引用类型的描述符字符串存储在**常量池**中，字节码指令只存储指向常量池的**数字索引**。
2.  **空间优化**：通过**常量池**机制实现共享。一种类型在全类范围内无论被使用多少次，在常量池中只存储一次其符号引用。字节码中大量使用轻量级的**索引**（通常为2字节）来代替冗长的字符串，极大地减少了存储空间。这种方法在类加载后，在方法区的运行时常量池中得到了延续和加强。

这种设计是编译器和虚拟机设计中经典的“符号表”思想的体现，完美地平衡了表达能力和空间效率。