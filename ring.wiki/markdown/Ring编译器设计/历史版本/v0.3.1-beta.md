# v0.3.1-beta

- 开始日期：2025-05-04
- 结束日期：2025-09-13


## 1. Feature: 实现 一个 vscode debugger 调试器插件 ✅

1. 实现dap协议的交互
2. cli 也通过 dap协议交互，不过可以转换，这样架构容易理解


[Ring-vscode-调试插件设计细节](./Ring-vscode-调试插件.md)

![Ring-vscode-调试插件](./000.png)




## 2. Feature: 实现显式类型转换，基础类型 ✅

暂时只支持基础类型

```
@bool(1);
@int(true);
@int64(2);
@double(1);
@string(23);
```




## 3. Feature: 切片运算符 ✅


### 3.1. 基本语法 支持数组和字符串的切片操作

```ring
string_value[begion:end];

array_value[begin:end];
```

### 3.2. begin end 都可以省略

```ring
string_value[begion:end];
string_value[:end];
string_value[begion:];
string_value[:];

array_value[begin:end];
array_value[:end];
array_value[begin:];
array_value[:];
```

### 3.3. 切片是深度赋值，产生的是个新数组


### 3.4. 系统性测试

数组元素类型覆盖：
- bool
- int
- int64
- double
- string
- class-ob
- 多维数组
- 匿名函数数组





## 4. Proposal: 支持定义类型别名 ✅


### 4.1 基础类型别名的定义

```
typedef TaskIsBilling  = bool;
typedef TaskCreateTime = int;
typedef TaskID         = int64;
typedef TaskScore      = double;
typedef TaskStatus     = string;
```

### 4.2 通过类型别名定义变量

```
	var TaskIsBilling  task_is_billing;
	var TaskCreateTime task_created_time;
	var TaskID         task_id;
	var TaskScore      task_score;
	var TaskStatus     task_status;
```


### 4.3 可以给类型别名定义变量赋值+访问

```
	task_is_billing 	= true;
	task_created_time 	= 1234567890;
	task_id 			= 1234567890123456789L;
	task_score 			= 3.14;
	task_status 		= "pending";


   fmt::println(task_is_billing);
	fmt::println(task_created_time);
	fmt::println(task_id);
	fmt::println(task_score);
	fmt::println(task_status);
```


### 4.5 可以扩展到数组


```
typedef BoolArray    = bool[];
typedef IntArray     = int[];
typedef Int64Array   = int64[];
typedef DoubleArray  = double[];
typedef StringArray  = string[];
```


### 4.6 可以扩展到多维数组


```
typedef BoolArray    = bool[,];
typedef IntArray     = int[,];
typedef Int64Array   = int64[,];
typedef DoubleArray  = double[,];
typedef StringArray  = string[,];
```


### 4.7 可以扩展到匿名函数

```
typedef FuncType0 = fn();

typedef FuncType1 = FuncType0;
```











## 5. Feature: for-range 新语法 ✅


### 5.1 支持新的for-range 语法，快速range一个int/int64 ✅


```ring
// [0,len) 区间遍历
for value = range 0..len {

}


// [0,len] 区间遍历
for value = range 0..=len {

}


// [0,len) 区间遍历，指定步长
for value = range 0..len:step {

}
```


- 指定start
- 指定end
- 指定step，step可以是负数
- 指定range类型，int/int64/double



### 5.2 for-range 支持 array ✅


1. 支持捕获index和value

```ring

for index, item_value = range array {
   
}
```

2. 支持占位符号捕获

```ring
// 只捕获index
for index, _ = range array {

} 


// 只捕获value
for _, item_value = range array {

} 
```


### 5.3 for-range 的语义检查，主要是类型是否匹配 ✅

```
fn test_1() {
	var int64 i;
	var bool[] value;
	var bool[,] bool_array = bool[,]{
		bool[]{true, false},
		bool[]{false, true},
	};


	for _, value = range bool_array {
		fmt::println(i, value);
	}
}
```

其中：value 必须是 bool_array 的下一个纬度，也就是 bool[!1]

### 5.4 系统性测试 ✅

1. 对于 step：覆盖 int/int64/double
2. 对于 linear：覆盖各种 array
   1. array 是常量/变量的情况
   2. 多维数组
3. 在 range数组的时候，append数组会发生什么情况
   1. 会立即更新，本次循环即生效，而golang不是
4. 在 range数字的时候，数字发生变化会怎样
   1. 本次循环不会生效，因为数组是按照值入栈的








## 6. Featrue: 支持定义enum 枚举类型 ✅

对于 TaskType ，这里有个隐式行为，那就是 
```
typedef TaskType = string;
enum TaskType {
	A = "A";
	B = "B";
}

这样的话，就可以使用 TaskType::A 了
```

```
// TaskType 是个类型
// Task::A Task::B 本质上是个常量
typedef TaskType = enum string {
	A = "A";
	B = "B";
};
// 后续可以使用

fmt::println(TaskType::A);

// TaskTemp 是个类型
// Task::A Task::B 本质上是个常量
typedef TaskTemp = enum Task { // Task is class
	A = Task {

	};
	B = Task {

	};
}
```

使用 enum
TaskType::A
TaskTemp::A

如果 import package 的 enum
package::TaskType::A






## 7. Feature: 引入 std 标准库 json ✅

```
var Job job_value;
var string str_value;



str_value = json::encode(job_value);

job_value = json::decode(Job, str_value);

```


var Job job_value;

json_decode(json_string, &job_value);


1. 支持解析 class
2. 支持解析 array
3. 支持嵌套解析





## 8. Feature: 支持  二进制、八进制、十六进制 常量表示 ✅


1. 支持二进制 格式 0b123
2. 支持16进制 格式 0xABDE
3. 支持助记符分割 格式 1_000 0b1_0000 0xFF_FFFF


## 9. Feature: 支持助记符分割数字格式 1_000 0b1_0000 0xFF_FFFF ✅




## 10. Feature: 支持位运算 ✅

1. 添加右移，左移运算
2. 支持按位 取反 与 或 异或 运算
3. 系统性测试，覆盖 int/int64 
4. 逻辑右移，算术右移




## 11. Feature: 支持括号运算符 ✅

系统性测试

1. 支持给常量表达式添加括号运算符
   - 基础类型：bool/int/int67/double/string
   - 派生类型：数组、类
2. 可以添加多个括号，如：(((bool)))
3. 通过括号运算 改变 数学运算的优先级






## 12. Feature: 支持使用第三方包 package中的类 ✅

```
import {
	debug;
	fmt;
	encoding;
	reflect;
}


fn test_0() {
	fmt::println("test_0------------------\n");

	var debug::TestClass local_test_class_value_0;
	local_test_class_value_0 = debug::TestClass{
	};
	fmt::println(local_test_class_value_0);
}

fn test_1() {
	fmt::println("test_1------------------\n");

	var debug::TestClass[] local_test_class_array_0 = debug::TestClass[]{
		debug::TestClass{
			Bool:    true,
			Int:     2,
			Int64:   3L,
			Double:  44.44,
			String: "hello ring"
		},
		debug::TestClass{
			Bool:    true,
			Int:     2,
			Int64:   3L,
			Double:  44.44,
			String: "hello ring"
		},
	};

	fmt::println(local_test_class_array_0);
}
```







## 13. Update: if/for 语句去掉括号，保持简洁 ✅

1. if 判断去掉括号 ✅
2. else if 去掉括号 ✅
3. elseif 关键字 调整为 else if ✅
4. for 语句去掉括号 ✅
5. do-for 语句去掉括号 ✅






## 14. Update: 函数定义中，希望去掉参数的 var 关键字  ✅

```ring
fn test(int64[] array) {

}
```






## 15. Update: 字符串的拼接 使用 + 运算符  ✅

### 15.1 基础用法 ✅

```ring
	var string local_string_value_0 = "a";

	local_string_value_0 = local_string_value_0 + "b";

	local_string_value_0 += "b";

```


### 15.2 字符串数组元素也支持 ✅

```ring
	var string[] local_string_array_0 = string[]{"", ""};

	local_string_array_0[0] = "a" + "b";

	local_string_array_0[0] = local_string_array_0[0] + "--";

	local_string_array_0[0] += "a" + "b";

	local_string_array_0[0] += "--";

```


### 15.3 多维字符串数组元素也支持 ✅

```ring
	var string[,] local_string_array_0 = string[,]{
		string[]{"1", "2"},
		string[]{"3", "4"},
	};

   local_string_array_0[0,0] = "a" + "b";

	local_string_array_0[0,0] = local_string_array_0[0,0] + "--";

	local_string_array_0[0,0] += "a" + "b";

	local_string_array_0[0,0] += "--";
```

### 15.4 类数组元素也支持 ✅


```ring

typedef Job = class {
    var bool    Bool;
    var int     Int;
	 var int64   Int64;
    var double  Double;
    var string  String;
}

	var Job local_job_value_0;

	local_job_value_0.String = "a" + "b";

	local_job_value_0.String += "c" + "d";


	local_job_value_0.String += "efghijklmnopqrstuvwxyz";
```

### 15.5 类数组元素也支持 ✅


```ring

typedef Job = class {
    var bool    Bool;
    var int     Int;
	 var int64   Int64;
    var double  Double;
    var string  String;
}

	var Job[] local_job_array_0 = new Job[2];

	local_job_array_0[0].String = "a" + "b";

	local_job_array_0[0].String += "c" + "d";

	local_job_array_0[0].String += "efghijklmnopqrstuvwxyz";

	fmt::printf("local_job_array_0={}\n", local_job_array_0);
```

### 15.6 类数组元素也支持 ✅


```ring

typedef Job = class {
    var bool    Bool;
    var int     Int;
	 var int64   Int64;
    var double  Double;
    var string  String;
}

	var Job[,] local_job_array_0 = new Job[2,2];

	local_job_array_0[0,0].String = "a" + "b";

	local_job_array_0[0,0].String += "c" + "d";

	local_job_array_0[0,0].String += "efghijklmnopqrstuvwxyz";

	fmt::printf("local_job_array_0={}\n", local_job_array_0);
```





## 16. Feature: 在赋值语句中，支持占位符 ✅

```ring
for _, value = range array {

}
```


1. 赋值语句
2. for-range 语句的应用












## 17. Feature: 完善一下 标准库 ✅


### 17.1 std package strings ✅


```ring
// has_prefix reports whether the string s begins with prefix.
fn has_prefix(string s, string prefix) -> (bool);

// has_suffix reports whether the string s ends with suffix.
fn has_suffix(string s, string suffix) -> (bool);

// trim_prefix returns s without the provided leading prefix string.
// If s doesn't start with prefix, s is returned unchanged.
fn trim_prefix(string s, string prefix) -> (string);

// trim_suffix returns s without the provided trailing suffix string.
// If s doesn't end with suffix, s is returned unchanged.
fn trim_suffix(string s, string suffix) -> (string);
```



### 17.2 std package os ✅

```ring
// return OS Name and Architecture
// e.g. "linux", "x86_64"
// e.g. "windows", "x86_64"
// e.g. "darwin", "x86_64"
@native
fn platform() -> (string, string);
```


### 17.3 std package reflect ✅

支持获取 struct 中 field名字和value

```ring
@native
fn get_obj_fields(any class_obj) -> (string[]);

@native
fn get_obj_field_type(any class_obj, string field_name) -> (string);

@native
fn get_obj_field_value(any class_obj, string field_name) -> (any);

@native
fn set_obj_field_value(any class_obj, string field_name, any value);
```







## 18. Feature: 需要加个强制限制，native 函数不能含有block  derive函数必须含有block ✅
